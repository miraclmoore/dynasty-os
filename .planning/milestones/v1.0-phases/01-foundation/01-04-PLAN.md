---
phase: 01-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - apps/desktop/src/App.tsx
  - apps/desktop/src/main.tsx
  - apps/desktop/src/store/dynasty-store.ts
  - apps/desktop/src/store/index.ts
  - apps/desktop/src/pages/LauncherPage.tsx
  - apps/desktop/src/pages/DashboardPage.tsx
  - apps/desktop/src/components/CreateDynastyModal.tsx
  - apps/desktop/src/components/DynastyCard.tsx
  - apps/desktop/src/components/DynastySwitcher.tsx
  - apps/desktop/src/components/ExportImportControls.tsx
  - apps/desktop/src/lib/dynasty-service.ts
  - apps/desktop/src/lib/export-import.ts
  - apps/desktop/src/lib/uuid.ts
autonomous: false

must_haves:
  truths:
    - "User can launch the app and see a dynasty launcher listing all existing dynasties"
    - "User can create a new dynasty by selecting sport, entering team name, coach name, start year, and game version"
    - "User can click a dynasty card to open it and see a placeholder dashboard"
    - "User can switch between dynasties from any screen using a dynasty switcher"
    - "User can delete a dynasty with a confirmation step"
    - "User can export a dynasty as a JSON file using a save dialog"
    - "User can import a previously exported dynasty JSON file"
    - "Imported dynasty appears in the launcher immediately"
    - "All data persists across app restart (closing and reopening the app)"
    - "App functions with no network connection"
  artifacts:
    - path: "apps/desktop/src/store/dynasty-store.ts"
      provides: "Zustand store for active dynasty and dynasty list"
      exports: ["useDynastyStore"]
    - path: "apps/desktop/src/pages/LauncherPage.tsx"
      provides: "Dynasty launcher/list view"
      min_lines: 40
    - path: "apps/desktop/src/pages/DashboardPage.tsx"
      provides: "Placeholder dashboard for active dynasty"
      min_lines: 20
    - path: "apps/desktop/src/components/CreateDynastyModal.tsx"
      provides: "Dynasty creation form/wizard"
      min_lines: 60
    - path: "apps/desktop/src/components/DynastySwitcher.tsx"
      provides: "Dynasty switching dropdown accessible from any screen"
      min_lines: 20
    - path: "apps/desktop/src/lib/dynasty-service.ts"
      provides: "CRUD operations for dynasties via Dexie"
      exports: ["createDynasty", "getDynasties", "getDynasty", "deleteDynasty", "updateDynasty"]
    - path: "apps/desktop/src/lib/export-import.ts"
      provides: "JSON export and import with validation"
      exports: ["exportDynasty", "importDynasty"]
  key_links:
    - from: "apps/desktop/src/lib/dynasty-service.ts"
      to: "@dynasty-os/db"
      via: "imports db instance for Dexie operations"
      pattern: "import.*db.*from.*@dynasty-os/db"
    - from: "apps/desktop/src/components/CreateDynastyModal.tsx"
      to: "@dynasty-os/sport-configs"
      via: "getSportConfig for team/conference dropdowns"
      pattern: "import.*getSportConfig.*from.*@dynasty-os/sport-configs"
    - from: "apps/desktop/src/store/dynasty-store.ts"
      to: "apps/desktop/src/lib/dynasty-service.ts"
      via: "store actions call service CRUD functions"
      pattern: "import.*dynasty-service"
    - from: "apps/desktop/src/App.tsx"
      to: "LauncherPage and DashboardPage"
      via: "conditional rendering based on active dynasty"
      pattern: "activeDynasty.*LauncherPage.*DashboardPage"
---

<objective>
Build the dynasty management UI: a launcher that lists dynasties, a creation wizard, dynasty
switching from any screen, delete with confirmation, and JSON export/import. This completes all
Phase 1 requirements (FOUND-01 through FOUND-06).

Purpose: This plan delivers the user-facing functionality. After this plan, a user can launch the
app, create dynasties, switch between them, and export/import data -- the full Phase 1 success
criteria are met.

Output: Working dynasty management with CRUD, switching, export/import, and data persistence.
</objective>

<execution_context>
@/Users/chanmoore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chanmoore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md

Prior plans established:
- 01-01: Monorepo with pnpm + Turborepo, React + Vite + Tailwind desktop app
- 01-02: Tauri 2.x shell, native window rendering React frontend
- 01-03: Core types (Dynasty, Season, Game, Player), Dexie DB schema, sport configs (CFB + Madden)

This plan builds on ALL of those to create the first user-facing functionality.

Key packages to import from:
- @dynasty-os/core-types: Dynasty, SportType, SportConfig types
- @dynasty-os/db: db instance (Dexie), DynastyDB
- @dynasty-os/sport-configs: getSportConfig(), cfbConfig, maddenConfig

UI framework: React 18, Tailwind CSS, Zustand for state
No routing library needed yet -- use simple conditional rendering (Launcher vs Dashboard)
UUID generation: Use crypto.randomUUID() (available in modern browsers and Tauri WebView)

Design direction: Dark theme (bg-gray-900 base), clean/modern, card-based layouts.
No need for complex animations or transitions at this stage.

For export/import:
- Export: Serialize dynasty + all related records (seasons, games, players, playerSeasons) as JSON
- Import: Validate JSON structure, check for ID conflicts, insert into DB
- Use Tauri's dialog API for save/open file dialogs (or browser file APIs as fallback)
  Tauri v2 dialog: @tauri-apps/plugin-dialog (install if needed)
  Tauri v2 file system: @tauri-apps/plugin-fs (install if needed)
  If Tauri plugins add complexity, fall back to browser File API (input type=file for import,
  Blob download for export) -- this works fine in WebView and avoids plugin wiring.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dynasty service layer and Zustand store</name>
  <files>
    apps/desktop/src/lib/uuid.ts
    apps/desktop/src/lib/dynasty-service.ts
    apps/desktop/src/lib/export-import.ts
    apps/desktop/src/store/dynasty-store.ts
    apps/desktop/src/store/index.ts
  </files>
  <action>
    1. Create apps/desktop/src/lib/uuid.ts:
       ```ts
       export function generateId(): string {
         return crypto.randomUUID();
       }
       ```

    2. Create apps/desktop/src/lib/dynasty-service.ts with CRUD operations:
       ```ts
       import { db } from '@dynasty-os/db';
       import type { Dynasty } from '@dynasty-os/core-types';
       import { generateId } from './uuid';

       export async function createDynasty(input: {
         name: string;
         sport: SportType;
         teamName: string;
         coachName: string;
         startYear: number;
         gameVersion: string;
       }): Promise<Dynasty> {
         const now = Date.now();
         const dynasty: Dynasty = {
           id: generateId(),
           ...input,
           currentYear: input.startYear,
           createdAt: now,
           updatedAt: now,
         };
         await db.dynasties.add(dynasty);
         return dynasty;
       }

       export async function getDynasties(): Promise<Dynasty[]> {
         return db.dynasties.orderBy('updatedAt').reverse().toArray();
       }

       export async function getDynasty(id: string): Promise<Dynasty | undefined> {
         return db.dynasties.get(id);
       }

       export async function updateDynasty(id: string, updates: Partial<Dynasty>): Promise<void> {
         await db.dynasties.update(id, { ...updates, updatedAt: Date.now() });
       }

       export async function deleteDynasty(id: string): Promise<void> {
         // Delete dynasty and all related records in a transaction
         await db.transaction('rw', [db.dynasties, db.seasons, db.games, db.players, db.playerSeasons], async () => {
           // Delete related records first
           await db.playerSeasons.where('dynastyId').equals(id).delete();
           await db.players.where('dynastyId').equals(id).delete();
           await db.games.where('dynastyId').equals(id).delete();
           await db.seasons.where('dynastyId').equals(id).delete();
           // Delete the dynasty itself
           await db.dynasties.delete(id);
         });
       }
       ```

    3. Create apps/desktop/src/lib/export-import.ts:
       ```ts
       import { db } from '@dynasty-os/db';
       import type { Dynasty, Season, Game, Player, PlayerSeason } from '@dynasty-os/core-types';
       import { generateId } from './uuid';

       interface DynastyExport {
         version: 1;
         exportedAt: number;
         dynasty: Dynasty;
         seasons: Season[];
         games: Game[];
         players: Player[];
         playerSeasons: PlayerSeason[];
       }

       export async function exportDynasty(dynastyId: string): Promise<string> {
         const dynasty = await db.dynasties.get(dynastyId);
         if (!dynasty) throw new Error(`Dynasty not found: ${dynastyId}`);

         const seasons = await db.seasons.where('dynastyId').equals(dynastyId).toArray();
         const games = await db.games.where('dynastyId').equals(dynastyId).toArray();
         const players = await db.players.where('dynastyId').equals(dynastyId).toArray();
         const playerSeasons = await db.playerSeasons.where('dynastyId').equals(dynastyId).toArray();

         const data: DynastyExport = {
           version: 1,
           exportedAt: Date.now(),
           dynasty,
           seasons,
           games,
           players,
           playerSeasons,
         };

         return JSON.stringify(data, null, 2);
       }

       export async function importDynasty(jsonString: string): Promise<Dynasty> {
         const data: DynastyExport = JSON.parse(jsonString);

         // Validate structure
         if (!data.version || !data.dynasty || !data.dynasty.id) {
           throw new Error('Invalid dynasty export file');
         }
         if (data.version !== 1) {
           throw new Error(`Unsupported export version: ${data.version}`);
         }

         // Check for existing dynasty with same ID
         const existing = await db.dynasties.get(data.dynasty.id);
         const needsNewIds = !!existing;

         if (needsNewIds) {
           // Remap all IDs to avoid conflicts
           const dynastyIdMap = new Map<string, string>();
           const seasonIdMap = new Map<string, string>();
           const playerIdMap = new Map<string, string>();

           const newDynastyId = generateId();
           dynastyIdMap.set(data.dynasty.id, newDynastyId);

           data.dynasty.id = newDynastyId;
           data.dynasty.name = `${data.dynasty.name} (imported)`;
           data.dynasty.updatedAt = Date.now();

           // Remap season IDs
           for (const season of (data.seasons || [])) {
             const newId = generateId();
             seasonIdMap.set(season.id, newId);
             season.id = newId;
             season.dynastyId = newDynastyId;
           }

           // Remap player IDs
           for (const player of (data.players || [])) {
             const newId = generateId();
             playerIdMap.set(player.id, newId);
             player.id = newId;
             player.dynastyId = newDynastyId;
           }

           // Remap game IDs and FKs
           for (const game of (data.games || [])) {
             game.id = generateId();
             game.dynastyId = newDynastyId;
             game.seasonId = seasonIdMap.get(game.seasonId) || game.seasonId;
           }

           // Remap playerSeason IDs and FKs
           for (const ps of (data.playerSeasons || [])) {
             ps.id = generateId();
             ps.dynastyId = newDynastyId;
             ps.playerId = playerIdMap.get(ps.playerId) || ps.playerId;
             ps.seasonId = seasonIdMap.get(ps.seasonId) || ps.seasonId;
           }
         }

         // Insert all records in a transaction
         await db.transaction('rw', [db.dynasties, db.seasons, db.games, db.players, db.playerSeasons], async () => {
           await db.dynasties.add(data.dynasty);
           if (data.seasons?.length) await db.seasons.bulkAdd(data.seasons);
           if (data.games?.length) await db.games.bulkAdd(data.games);
           if (data.players?.length) await db.players.bulkAdd(data.players);
           if (data.playerSeasons?.length) await db.playerSeasons.bulkAdd(data.playerSeasons);
         });

         return data.dynasty;
       }

       export function downloadJson(json: string, filename: string): void {
         const blob = new Blob([json], { type: 'application/json' });
         const url = URL.createObjectURL(blob);
         const a = document.createElement('a');
         a.href = url;
         a.download = filename;
         a.click();
         URL.revokeObjectURL(url);
       }

       export function readFileAsText(file: File): Promise<string> {
         return new Promise((resolve, reject) => {
           const reader = new FileReader();
           reader.onload = () => resolve(reader.result as string);
           reader.onerror = () => reject(reader.error);
           reader.readAsText(file);
         });
       }
       ```

    4. Create apps/desktop/src/store/dynasty-store.ts using Zustand:
       ```ts
       import { create } from 'zustand';
       import type { Dynasty } from '@dynasty-os/core-types';
       import * as dynastyService from '../lib/dynasty-service';
       import { exportDynasty, importDynasty, downloadJson, readFileAsText } from '../lib/export-import';

       interface DynastyState {
         dynasties: Dynasty[];
         activeDynasty: Dynasty | null;
         loading: boolean;
         error: string | null;

         // Actions
         loadDynasties: () => Promise<void>;
         createDynasty: (input: Parameters<typeof dynastyService.createDynasty>[0]) => Promise<Dynasty>;
         setActiveDynasty: (dynasty: Dynasty | null) => void;
         switchDynasty: (id: string) => Promise<void>;
         deleteDynasty: (id: string) => Promise<void>;
         exportDynasty: (id: string) => Promise<void>;
         importDynastyFromFile: (file: File) => Promise<Dynasty>;
       }

       export const useDynastyStore = create<DynastyState>((set, get) => ({
         dynasties: [],
         activeDynasty: null,
         loading: false,
         error: null,

         loadDynasties: async () => {
           set({ loading: true, error: null });
           try {
             const dynasties = await dynastyService.getDynasties();
             set({ dynasties, loading: false });
           } catch (e) {
             set({ error: (e as Error).message, loading: false });
           }
         },

         createDynasty: async (input) => {
           const dynasty = await dynastyService.createDynasty(input);
           await get().loadDynasties();
           set({ activeDynasty: dynasty });
           return dynasty;
         },

         setActiveDynasty: (dynasty) => {
           set({ activeDynasty: dynasty });
         },

         switchDynasty: async (id) => {
           const dynasty = await dynastyService.getDynasty(id);
           if (dynasty) {
             set({ activeDynasty: dynasty });
           }
         },

         deleteDynasty: async (id) => {
           await dynastyService.deleteDynasty(id);
           const { activeDynasty } = get();
           if (activeDynasty?.id === id) {
             set({ activeDynasty: null });
           }
           await get().loadDynasties();
         },

         exportDynasty: async (id) => {
           const json = await exportDynasty(id);
           const dynasty = get().dynasties.find(d => d.id === id);
           const filename = `dynasty-${dynasty?.name.replace(/\s+/g, '-').toLowerCase() || id}.json`;
           downloadJson(json, filename);
         },

         importDynastyFromFile: async (file) => {
           const text = await readFileAsText(file);
           const dynasty = await importDynasty(text);
           await get().loadDynasties();
           return dynasty;
         },
       }));
       ```

    5. Create apps/desktop/src/store/index.ts re-exporting:
       ```ts
       export { useDynastyStore } from './dynasty-store';
       ```
  </action>
  <verify>
    All files compile without TypeScript errors.
    `pnpm build` from root succeeds.
    Imports from @dynasty-os/db and @dynasty-os/sport-configs resolve correctly.
  </verify>
  <done>Dynasty service layer (CRUD, export, import), Zustand store, and utility functions exist. All TypeScript compiles. The service layer uses Dexie transactions for cascade delete and atomic import.</done>
</task>

<task type="auto">
  <name>Task 2: Dynasty management UI pages and components</name>
  <files>
    apps/desktop/src/App.tsx
    apps/desktop/src/main.tsx
    apps/desktop/src/pages/LauncherPage.tsx
    apps/desktop/src/pages/DashboardPage.tsx
    apps/desktop/src/components/CreateDynastyModal.tsx
    apps/desktop/src/components/DynastyCard.tsx
    apps/desktop/src/components/DynastySwitcher.tsx
    apps/desktop/src/components/ExportImportControls.tsx
  </files>
  <action>
    1. Create apps/desktop/src/components/DynastyCard.tsx:
       - Receives a Dynasty object as prop
       - Displays: dynasty name, sport badge (CFB or Madden), team name, coach name, current year, game version
       - Click handler to select/open the dynasty
       - Small action buttons: Export (download icon), Delete (trash icon with confirmation)
       - Delete shows a confirm dialog (window.confirm is fine for now) before calling store.deleteDynasty
       - Tailwind styling: bg-gray-800 card with hover:bg-gray-750, rounded-lg, padding, shadow

    2. Create apps/desktop/src/components/CreateDynastyModal.tsx:
       - Modal overlay (fixed inset-0, bg-black/50 backdrop, centered white/dark card)
       - Form fields:
         - Sport selector: radio/button toggle for "College Football" or "Madden NFL"
         - Team name: text input (later phases will use dropdown from sport config teams)
           For now, also include a dropdown populated from getSportConfig(sport).teams so users
           can pick from the list OR type a custom team name. Use a combobox pattern or simple
           select element.
         - Coach name: text input
         - Start year: number input (default to current year)
         - Game version: dropdown from getSportConfig(sport).gameVersions
         - Dynasty name: auto-generated from "{teamName} Dynasty" but editable
       - Submit button calls store.createDynasty() and closes modal
       - Cancel button closes modal
       - Basic validation: all required fields must be filled
       - On sport change, reset team and game version selections (different config)

    3. Create apps/desktop/src/components/DynastySwitcher.tsx:
       - Dropdown component showing the active dynasty name
       - On click, shows list of all dynasties
       - Clicking a dynasty calls store.switchDynasty(id)
       - "Back to Launcher" option at bottom that calls store.setActiveDynasty(null)
       - Tailwind: positioned in header area, dropdown with bg-gray-800

    4. Create apps/desktop/src/components/ExportImportControls.tsx:
       - Import button with hidden file input (accept=".json")
       - On file select, calls store.importDynastyFromFile(file)
       - Shows success toast/message on import (simple state-based message, no toast library needed)
       - Shows error message if import fails (invalid JSON, invalid structure)
       - Styled as a subtle button row, works on the launcher page

    5. Create apps/desktop/src/pages/LauncherPage.tsx:
       - Header: "Dynasty OS" title, subtitle "Your Dynasty Companion"
       - Grid of DynastyCard components for each dynasty in store
       - "Create New Dynasty" button that opens CreateDynastyModal
       - ExportImportControls for importing
       - Empty state: when no dynasties, show a welcome message and prominent create button
       - On mount (useEffect), call store.loadDynasties()
       - Tailwind: responsive grid (1 col mobile, 2 cols md, 3 cols lg), centered container

    6. Create apps/desktop/src/pages/DashboardPage.tsx:
       - Placeholder dashboard for the active dynasty
       - Header with dynasty name, sport badge, and DynastySwitcher
       - Body: "Dashboard coming in Phase 2" message
       - Display key dynasty info: team, coach, current year, sport, game version
       - This is intentionally minimal -- Phase 2 builds the real dashboard

    7. Update apps/desktop/src/App.tsx:
       - If no activeDynasty in store, render LauncherPage
       - If activeDynasty exists, render DashboardPage
       - Import and use useDynastyStore for this conditional

    8. Verify the full flow works:
       - `pnpm tauri dev` launches the app
       - Launcher shows (empty state since no dynasties)
       - Create a dynasty (fill form, submit)
       - Dynasty card appears in launcher
       - Click dynasty card to open dashboard
       - Dynasty switcher shows, can go back to launcher
       - Create a second dynasty, switch between them
       - Export a dynasty (JSON file downloads)
       - Delete a dynasty (with confirmation)
       - Import the exported JSON file
       - Close and reopen app -- dynasties persist
  </action>
  <verify>
    `pnpm tauri dev` launches and shows the launcher page.
    Creating a dynasty with all fields works -- dynasty appears in the list.
    Clicking a dynasty opens the dashboard placeholder.
    Dynasty switcher dropdown works from the dashboard.
    Export downloads a .json file with dynasty data.
    Import loads a .json file and the dynasty appears in the list.
    Delete with confirmation removes the dynasty.
    Closing and reopening the app shows persisted dynasties.
    `pnpm build` from root succeeds.
  </verify>
  <done>Full dynasty management UI is functional: create, list, open, switch, delete, export, import. Data persists in IndexedDB across restarts. All Phase 1 requirements (FOUND-01 through FOUND-06) are met.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Phase 1 Foundation: monorepo, Tauri shell, database, sport configs, and dynasty
    management UI. The app should be fully functional with create/switch/delete dynasties,
    JSON export/import, and offline-first data persistence.
  </what-built>
  <how-to-verify>
    Launch the app with `pnpm tauri dev` from apps/desktop/ and verify:

    1. FOUND-01: Create a new dynasty
       - Click "Create New Dynasty"
       - Select "College Football" as sport
       - Pick a team from the dropdown (or type one)
       - Enter coach name, start year, game version
       - Submit -- dynasty should appear in the launcher

    2. FOUND-02: Multi-dynasty management
       - Create a second dynasty (try Madden this time)
       - Both dynasties should show as cards in the launcher
       - Game version dropdown should change between CFB and Madden

    3. FOUND-03: Switch between dynasties
       - Click a dynasty card to open it
       - Verify the dashboard shows correct dynasty info
       - Use the dynasty switcher dropdown to switch to the other dynasty
       - Verify info updates correctly
       - Click "Back to Launcher" to return

    4. FOUND-04: Export dynasty
       - Click the export button on a dynasty card
       - A .json file should download
       - Open it -- should contain dynasty data, empty arrays for seasons/games/players

    5. FOUND-05: Import dynasty
       - Delete one dynasty
       - Use the import button on the launcher
       - Select the .json file exported in step 4
       - Dynasty should reappear in the launcher

    6. FOUND-06: Offline functionality
       - Disconnect from internet (airplane mode or disable Wi-Fi)
       - Close and reopen the app
       - All dynasties should still be there
       - Create, switch, delete should all work offline

    7. Performance
       - App should open quickly (target <3s)
       - Feel responsive, no lag on interactions
  </how-to-verify>
  <resume-signal>Type "approved" if all checks pass, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm tauri dev` launches app showing dynasty launcher
2. Create dynasty flow: sport select -> team -> coach -> year -> version -> submit
3. Dynasty list: cards with sport badge, team, coach, year info
4. Dynasty switching: click card -> dashboard, switcher dropdown -> switch, back to launcher
5. Export: downloads .json file with complete dynasty data
6. Import: loads .json, handles ID conflicts, dynasty appears in list
7. Delete: confirmation dialog, cascade deletes related records
8. Persistence: close app, reopen, all data still present
9. Offline: all operations work without network
10. `pnpm build` from root succeeds
</verification>

<success_criteria>
- FOUND-01: User can create a dynasty with sport, team, coach, year, game version
- FOUND-02: Multiple dynasties from a unified launcher
- FOUND-03: Switch between dynasties from any screen
- FOUND-04: Export dynasty as JSON file
- FOUND-05: Import previously exported dynasty JSON
- FOUND-06: App functions 100% offline
- All data persists in IndexedDB across app restarts
- Performance feels snappy (<3s cold start, responsive interactions)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
