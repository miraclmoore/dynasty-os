---
phase: 07-achievements
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core-types/src/achievement.ts
  - packages/core-types/src/index.ts
  - packages/db/src/schema.ts
  - packages/db/src/dynasty-db.ts
  - apps/desktop/src/lib/achievement-service.ts
  - apps/desktop/src/store/achievement-store.ts
  - apps/desktop/src/store/index.ts
autonomous: true
requirements:
  - ACHV-01

must_haves:
  truths:
    - "Achievement engine evaluates win-count milestones (10, 25, 50, 100, 200 wins) from game data"
    - "Achievement engine evaluates bowl win milestones (1, 5, 10, 25 bowl wins) from season data"
    - "Achievement engine evaluates championship milestones (1, 3, 5, 10 championships) from season data"
    - "Newly unlocked achievements are written to the DB with dynastyId, achievementId, and unlockedAt timestamp"
    - "evaluateAchievements is idempotent — already-unlocked achievements are not re-inserted"
  artifacts:
    - path: "packages/core-types/src/achievement.ts"
      provides: "Achievement interface"
      exports: ["Achievement", "MILESTONE_DEFINITIONS"]
    - path: "apps/desktop/src/lib/achievement-service.ts"
      provides: "Milestone condition definitions, evaluateAchievements(dynastyId)"
      exports: ["evaluateAchievements", "getAchievementsByDynasty"]
    - path: "apps/desktop/src/store/achievement-store.ts"
      provides: "Zustand store for loaded achievement state"
      exports: ["useAchievementStore"]
    - path: "packages/db/src/schema.ts"
      provides: "DB v5 schema with achievements table"
      contains: "achievements"
  key_links:
    - from: "apps/desktop/src/lib/achievement-service.ts"
      to: "packages/db/src/dynasty-db.ts"
      via: "db.achievements.put() for persistence"
      pattern: "db\\.achievements\\.(put|toArray|where)"
    - from: "apps/desktop/src/store/achievement-store.ts"
      to: "apps/desktop/src/lib/achievement-service.ts"
      via: "getAchievementsByDynasty() in loadAchievements action"
      pattern: "getAchievementsByDynasty"
---

<objective>
Define the Achievement type, migrate the database to v5 with an achievements table, implement the milestone condition engine with evaluateAchievements(), and create the Zustand store.

Purpose: The achievement engine is the core data layer for Phase 7. All UI in Plan 02 reads from this store and these services. The engine must be idempotent — safe to call on every save event without creating duplicates.

Output: Achievement type, DB v5 migration, achievement-service.ts with evaluateAchievements(), useAchievementStore.
</objective>

<execution_context>
@/Users/chanmoore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chanmoore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/db/src/schema.ts
@packages/db/src/dynasty-db.ts
@packages/core-types/src/index.ts
@apps/desktop/src/lib/game-service.ts
@apps/desktop/src/lib/season-service.ts
@apps/desktop/src/store/rivalry-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Achievement type, DB v5 migration, achievement service</name>
  <files>
    packages/core-types/src/achievement.ts
    packages/core-types/src/index.ts
    packages/db/src/schema.ts
    packages/db/src/dynasty-db.ts
    apps/desktop/src/lib/achievement-service.ts
  </files>
  <action>
**1. Create `packages/core-types/src/achievement.ts`:**

```ts
export interface Achievement {
  id: string;             // dynastyId + '-' + achievementId (compound key for upsert)
  dynastyId: string;
  achievementId: string;  // e.g. 'wins-10', 'bowl-wins-5', 'championships-1'
  category: 'wins' | 'bowl-wins' | 'championships';
  label: string;          // e.g. 'First 10 Wins'
  description: string;    // e.g. 'Win 10 games in your coaching career'
  threshold: number;      // numeric milestone value
  unlockedAt: number;     // Date.now() timestamp
}
```

Export MILESTONE_DEFINITIONS as a readonly array — each entry has achievementId, category, label, description, threshold:

```ts
export const MILESTONE_DEFINITIONS = [
  // Wins
  { achievementId: 'wins-10', category: 'wins', label: 'First 10 Wins', description: 'Win 10 games in your career', threshold: 10 },
  { achievementId: 'wins-25', category: 'wins', label: '25 Wins', description: 'Win 25 games in your career', threshold: 25 },
  { achievementId: 'wins-50', category: 'wins', label: '50 Wins', description: 'Win 50 games in your career', threshold: 50 },
  { achievementId: 'wins-100', category: 'wins', label: 'Century Mark', description: 'Win 100 games in your career', threshold: 100 },
  { achievementId: 'wins-200', category: 'wins', label: '200 Wins', description: 'Win 200 games in your career', threshold: 200 },
  // Bowl wins
  { achievementId: 'bowl-wins-1', category: 'bowl-wins', label: 'First Bowl Win', description: 'Win your first bowl game', threshold: 1 },
  { achievementId: 'bowl-wins-5', category: 'bowl-wins', label: 'Bowl Champion x5', description: 'Win 5 bowl games', threshold: 5 },
  { achievementId: 'bowl-wins-10', category: 'bowl-wins', label: 'Bowl Champion x10', description: 'Win 10 bowl games', threshold: 10 },
  { achievementId: 'bowl-wins-25', category: 'bowl-wins', label: 'Bowl Legend', description: 'Win 25 bowl games', threshold: 25 },
  // Championships
  { achievementId: 'championships-1', category: 'championships', label: 'First Title', description: 'Win your first championship', threshold: 1 },
  { achievementId: 'championships-3', category: 'championships', label: 'Dynasty Emerging', description: 'Win 3 championships', threshold: 3 },
  { achievementId: 'championships-5', category: 'championships', label: 'Dynasty Builder', description: 'Win 5 championships', threshold: 5 },
  { achievementId: 'championships-10', category: 'championships', label: 'Legendary Dynasty', description: 'Win 10 championships', threshold: 10 },
] as const;
```

**2. Add to `packages/core-types/src/index.ts`:**
Add `export * from './achievement';` at the end.

**3. Update `packages/db/src/schema.ts`:**
- Add `achievements` to SCHEMA: `achievements: 'id, dynastyId, achievementId, [dynastyId+achievementId]'`
- Change DB_VERSION from 4 to 5

**4. Update `packages/db/src/dynasty-db.ts`:**
- Add import: `import type { Achievement } from '@dynasty-os/core-types';`
- Add table declaration: `achievements!: Table<Achievement, string>;`
- Add `this.version(5).stores(SCHEMA);` in the constructor (keep existing version(1) and version(4))

**5. Create `apps/desktop/src/lib/achievement-service.ts`:**

```ts
import { db } from '@dynasty-os/db';
import { MILESTONE_DEFINITIONS } from '@dynasty-os/core-types';
import type { Achievement } from '@dynasty-os/core-types';

/**
 * evaluateAchievements: idempotent — queries current dynasty data, checks each
 * MILESTONE_DEFINITION condition, writes newly-unlocked achievements to DB.
 * Safe to call after any data save event (game logged, season ended, etc.).
 */
export async function evaluateAchievements(dynastyId: string): Promise<void> {
  // Load already-unlocked achievement IDs for this dynasty
  const existing = await db.achievements
    .where('dynastyId').equals(dynastyId)
    .toArray();
  const unlockedIds = new Set(existing.map((a) => a.achievementId));

  // Compute current stats
  const totalWins = await computeTotalWins(dynastyId);
  const totalBowlWins = await computeTotalBowlWins(dynastyId);
  const totalChampionships = await computeTotalChampionships(dynastyId);

  const now = Date.now();

  for (const def of MILESTONE_DEFINITIONS) {
    if (unlockedIds.has(def.achievementId)) continue; // already unlocked

    let currentValue: number;
    if (def.category === 'wins') currentValue = totalWins;
    else if (def.category === 'bowl-wins') currentValue = totalBowlWins;
    else currentValue = totalChampionships;

    if (currentValue >= def.threshold) {
      const achievement: Achievement = {
        id: `${dynastyId}-${def.achievementId}`,
        dynastyId,
        achievementId: def.achievementId,
        category: def.category as Achievement['category'],
        label: def.label,
        description: def.description,
        threshold: def.threshold,
        unlockedAt: now,
      };
      await db.achievements.put(achievement);
    }
  }
}

export async function getAchievementsByDynasty(dynastyId: string): Promise<Achievement[]> {
  return db.achievements.where('dynastyId').equals(dynastyId).toArray();
}

// ------- Private helpers -------

async function computeTotalWins(dynastyId: string): Promise<number> {
  const games = await db.games.where('dynastyId').equals(dynastyId).toArray();
  return games.filter((g) => g.result === 'W').length;
}

async function computeTotalBowlWins(dynastyId: string): Promise<number> {
  // Bowl wins: seasons where bowlResult === 'W' (bowlResult field on Season)
  // Check Season type — bowlResult is a string field set by SeasonEndModal.
  // A bowl win is when the season has a bowlGame (not null/undefined) and bowlResult === 'W'.
  const seasons = await db.seasons.where('dynastyId').equals(dynastyId).toArray();
  return seasons.filter((s) => s.bowlGame && s.bowlResult === 'W').length;
}

async function computeTotalChampionships(dynastyId: string): Promise<number> {
  // Championships: seasons where playoffResult === 'champion' (check Season type)
  // Season has playoffResult field. 'champion' is the value indicating a title.
  // If the field name or values differ from the Season type, adapt using the actual Season interface.
  const seasons = await db.seasons.where('dynastyId').equals(dynastyId).toArray();
  return seasons.filter((s) => s.playoffResult === 'champion').length;
}
```

IMPORTANT: Before writing computeTotalBowlWins and computeTotalChampionships, READ `packages/core-types/src/season.ts` to verify the exact field names and valid values for bowlResult and playoffResult. Adjust the filter logic to match the actual Season interface — do not assume field names.
  </action>
  <verify>
    <automated>cd /Users/chanmoore/dev/dynasty-os && pnpm run build 2>&1 | tail -20</automated>
    <manual>Confirm "5 packages" all build successfully with no TypeScript errors. Check that achievement.ts is exported from core-types index.</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>Full monorepo build passes (5/5 packages). Achievement type is in core-types. DB schema v5 includes achievements table. achievement-service.ts exports evaluateAchievements() and getAchievementsByDynasty(). No TypeScript errors.</done>
</task>

<task type="auto">
  <name>Task 2: Achievement Zustand store</name>
  <files>
    apps/desktop/src/store/achievement-store.ts
    apps/desktop/src/store/index.ts
  </files>
  <action>
**1. Create `apps/desktop/src/store/achievement-store.ts`:**

Follow the exact same Zustand reload-after-mutation pattern as rivalry-store.ts:

```ts
import { create } from 'zustand';
import type { Achievement } from '@dynasty-os/core-types';
import { getAchievementsByDynasty } from '../lib/achievement-service';

interface AchievementState {
  achievements: Achievement[];
  loading: boolean;
  error: string | null;
}

interface AchievementActions {
  loadAchievements: (dynastyId: string) => Promise<void>;
}

type AchievementStore = AchievementState & AchievementActions;

export const useAchievementStore = create<AchievementStore>((set) => ({
  achievements: [],
  loading: false,
  error: null,

  loadAchievements: async (dynastyId: string) => {
    set({ loading: true, error: null });
    try {
      const achievements = await getAchievementsByDynasty(dynastyId);
      // Sort by unlockedAt descending (most recently unlocked first)
      achievements.sort((a, b) => b.unlockedAt - a.unlockedAt);
      set({ achievements, loading: false });
    } catch (err) {
      set({ error: String(err), loading: false });
    }
  },
}));
```

**2. Update `apps/desktop/src/store/index.ts`:**
Add `export { useAchievementStore } from './achievement-store';` alongside the other store exports.
  </action>
  <verify>
    <automated>cd /Users/chanmoore/dev/dynasty-os && pnpm run build 2>&1 | tail -10</automated>
    <manual>Confirm useAchievementStore is exported from store/index.ts and build passes.</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>Build passes. useAchievementStore exported from store/index.ts. loadAchievements(dynastyId) queries achievement-service and sorts by unlockedAt descending.</done>
</task>

</tasks>

<verification>
- `pnpm run build` produces "5 packages" with no errors
- `packages/core-types/src/achievement.ts` exports Achievement interface and MILESTONE_DEFINITIONS (14 definitions across 3 categories)
- `packages/db/src/schema.ts` has DB_VERSION = 5 and achievements in SCHEMA
- `packages/db/src/dynasty-db.ts` has version(5).stores(SCHEMA) and `achievements!: Table<Achievement, string>`
- `apps/desktop/src/lib/achievement-service.ts` exports evaluateAchievements(dynastyId) and getAchievementsByDynasty(dynastyId)
- `apps/desktop/src/store/achievement-store.ts` exports useAchievementStore with loadAchievements
- `apps/desktop/src/store/index.ts` exports useAchievementStore
</verification>

<success_criteria>
Achievement engine data layer is complete. evaluateAchievements(dynastyId) can be called after any data save, is idempotent, and persists newly-unlocked achievements to the DB. The store provides React components read access to earned achievements. Plan 02 can wire these into save events and UI.
</success_criteria>

<output>
After completion, create `.planning/phases/07-achievements/07-01-SUMMARY.md`
</output>
