---
phase: 08-screenshot-ingestion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/desktop/src-tauri/capabilities/default.json
  - apps/desktop/src/lib/screenshot-service.ts
autonomous: true
requirements: [INGST-04, INGST-05]

must_haves:
  truths:
    - "screenshot-service.ts exports parseScreenshot(screenType, imageBase64, dynastyContext) and returns a typed ParsedScreenData object"
    - "All four screen types have distinct Vision API prompts with field extraction targets: schedule, player-stats, recruiting, depth-chart"
    - "API call failures return null (never throw) so callers receive a recoverable error signal"
    - "Tauri capabilities include dialog:allow-open so the file picker can open image files"
  artifacts:
    - path: "apps/desktop/src/lib/screenshot-service.ts"
      provides: "Claude Vision API integration — parseScreenshot() and all screen type definitions"
      exports: ["parseScreenshot", "ScreenType", "ParsedScreenData", "SCREEN_TYPE_LABELS"]
      min_lines: 120
    - path: "apps/desktop/src-tauri/capabilities/default.json"
      provides: "Tauri permission for dialog:allow-open and fs:allow-read-file"
      contains: "dialog:allow-open"
  key_links:
    - from: "apps/desktop/src/lib/screenshot-service.ts"
      to: "https://api.anthropic.com/v1/messages"
      via: "fetch with Authorization: Bearer header + base64 image in content array"
      pattern: "anthropic\\.com.*messages"
    - from: "apps/desktop/src/lib/screenshot-service.ts"
      to: "apps/desktop/src/lib/legacy-card-service.ts"
      via: "getApiKey() import — reuses existing Anthropic API key storage"
      pattern: "getApiKey"
---

<objective>
Create the screenshot ingestion service layer: Tauri file-open capability, Claude Vision API integration with four screen-type prompts, and a typed ParsedScreenData return shape for each screen type.

Purpose: The Vision API service is the computational core of Phase 8. Without it, the UI (08-02) has nothing to call. Isolating it here ensures the parsing logic is independently testable before the UI is wired.
Output: screenshot-service.ts with parseScreenshot(), updated capabilities JSON with dialog:allow-open.
</objective>

<execution_context>
@/Users/chanmoore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chanmoore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-screenshot-ingestion/08-CONTEXT.md
@apps/desktop/src/lib/narrative-service.ts
@apps/desktop/src/lib/legacy-card-service.ts
@apps/desktop/src-tauri/capabilities/default.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dialog:allow-open capability and create screenshot-service.ts</name>
  <files>
    apps/desktop/src-tauri/capabilities/default.json
    apps/desktop/src/lib/screenshot-service.ts
  </files>
  <action>
**Step A: Update capabilities/default.json**

Add "dialog:allow-open" and "fs:allow-read-file" to the permissions array alongside the existing dialog and fs permissions. The file currently has "dialog:allow-save", "fs:allow-write-text-file", "fs:allow-read-text-file", "fs:allow-exists", and "fs:scope-download". Add after "dialog:allow-save":
  - "dialog:allow-open"

And after "fs:allow-read-text-file":
  - "fs:allow-read-file"

**Step B: Create apps/desktop/src/lib/screenshot-service.ts**

This file integrates with Claude Vision API to parse in-game screenshots. Model: claude-haiku-4-5-20251001 (consistent with recruiting class grading — structured extraction suits Haiku; Sonnet is not needed here). Max tokens: 1000. API call pattern mirrors narrative-service.ts (fetch to https://api.anthropic.com/v1/messages, headers: x-api-key + anthropic-version: 2023-06-01 + content-type: application/json).

```typescript
// Types
export type ScreenType = 'schedule' | 'player-stats' | 'recruiting' | 'depth-chart';

export const SCREEN_TYPE_LABELS: Record<ScreenType, string> = {
  'schedule': 'Schedule / Game Results',
  'player-stats': 'Player Stats',
  'recruiting': 'Recruiting Class',
  'depth-chart': 'Depth Chart',
};

// ParsedScreenData shape — a union per screen type
export interface ScheduleParsedData {
  screenType: 'schedule';
  games: Array<{
    week?: number;
    opponent?: string;
    homeAway?: 'Home' | 'Away' | 'Neutral';
    teamScore?: number;
    opponentScore?: number;
    result?: 'W' | 'L';
    gameType?: string;
  }>;
}

export interface PlayerStatsParsedData {
  screenType: 'player-stats';
  players: Array<{
    name?: string;
    position?: string;
    stats: Record<string, number | string>;
  }>;
}

export interface RecruitingParsedData {
  screenType: 'recruiting';
  recruits: Array<{
    name?: string;
    position?: string;
    stars?: number;
    state?: string;
    nationalRank?: number;
  }>;
  classRank?: number;
  totalCommits?: number;
}

export interface DepthChartParsedData {
  screenType: 'depth-chart';
  entries: Array<{
    position?: string;
    playerName?: string;
    depth?: number;
  }>;
}

export type ParsedScreenData = ScheduleParsedData | PlayerStatsParsedData | RecruitingParsedData | DepthChartParsedData;
```

System prompts per screen type (stored as SCREEN_TYPE_PROMPTS: Record<ScreenType, string>):

- schedule: "You are parsing a CFB 25 in-game schedule screen. Extract each visible game row: week number, opponent team name, home/away/neutral indicator, team score, opponent score, win/loss result, and game type (regular, conference, bowl, playoff). Team name context: {teamName} ({season} season). Return ONLY valid JSON matching: {\"games\": [{\"week\": number|null, \"opponent\": string|null, \"homeAway\": \"Home\"|\"Away\"|\"Neutral\"|null, \"teamScore\": number|null, \"opponentScore\": number|null, \"result\": \"W\"|\"L\"|null, \"gameType\": string|null}]}. Leave fields null if not visible. No explanation — JSON only."

- player-stats: "You are parsing a CFB 25 player statistics screen. Extract each visible player row: player name, position, and all visible stat values with their labels as keys. Team context: {teamName} ({season} season). Return ONLY valid JSON matching: {\"players\": [{\"name\": string|null, \"position\": string|null, \"stats\": {\"statLabel\": value}}]}. Use stat labels exactly as shown on screen (e.g. \"YDS\", \"TD\", \"ATT\"). Leave fields null if not visible. No explanation — JSON only."

- recruiting: "You are parsing a CFB 25 recruiting class screen. Extract overall class rank, total commits count, and each visible recruit row: name, position, star rating (1-5), home state abbreviation, and national recruit rank. Team context: {teamName} ({season} season). Return ONLY valid JSON matching: {\"classRank\": number|null, \"totalCommits\": number|null, \"recruits\": [{\"name\": string|null, \"position\": string|null, \"stars\": number|null, \"state\": string|null, \"nationalRank\": number|null}]}. No explanation — JSON only."

- depth-chart: "You are parsing a CFB 25 depth chart screen. Extract each position and its starters/backups: position abbreviation, player name, and depth number (1=starter, 2=backup, etc.). Team context: {teamName} ({season} season). Return ONLY valid JSON matching: {\"entries\": [{\"position\": string|null, \"playerName\": string|null, \"depth\": number|null}]}. No explanation — JSON only."

Main export function:

```typescript
export async function parseScreenshot(
  screenType: ScreenType,
  imageBase64: string,
  dynastyContext: { teamName: string; season: string }
): Promise<ParsedScreenData | null>
```

Implementation:
1. Call getApiKey() — if null, return null (caller shows API key prompt)
2. Build prompt by replacing {teamName} and {season} in SCREEN_TYPE_PROMPTS[screenType]
3. POST to https://api.anthropic.com/v1/messages with:
   - model: 'claude-haiku-4-5-20251001'
   - max_tokens: 1000
   - messages: [{ role: 'user', content: [{ type: 'image', source: { type: 'base64', media_type: 'image/png', data: imageBase64 } }, { type: 'text', text: prompt }] }]
   - system: SCREEN_TYPE_PROMPTS[screenType] (pass as system message, use simpler user content)
   - Note: Actually pass the prompt text (with replacements) as the system message and image + "Parse this screenshot." as user content
4. Parse response.content[0].text as JSON
5. Add `screenType` property to the parsed object and cast to the appropriate typed shape
6. Wrap in try/catch — return null on any error (network, JSON parse, API error)

The `imageBase64` parameter is a raw base64 string (no data URL prefix — strip "data:image/...;base64," prefix if caller passes a data URL).
  </action>
  <verify>
    <automated>cd /Users/chanmoore/dev/dynasty-os && pnpm --filter @dynasty-os/desktop exec tsc --noEmit 2>&1 | tail -5</automated>
    <manual>Confirm capabilities/default.json contains "dialog:allow-open" and screenshot-service.ts exports parseScreenshot, ScreenType, ParsedScreenData, SCREEN_TYPE_LABELS</manual>
  </verify>
  <done>
    - capabilities/default.json includes "dialog:allow-open" and "fs:allow-read-file"
    - screenshot-service.ts exports parseScreenshot(), ScreenType, ParsedScreenData union type, SCREEN_TYPE_LABELS
    - All four screen types have distinct JSON-returning Vision API prompts with {teamName}/{season} template vars
    - TypeScript compiles with zero errors
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @dynasty-os/desktop exec tsc --noEmit` passes with zero errors
- screenshot-service.ts exists at apps/desktop/src/lib/screenshot-service.ts
- capabilities/default.json contains "dialog:allow-open"
- parseScreenshot() returns null on API key missing or any error (never throws)
</verification>

<success_criteria>
1. screenshot-service.ts compiles cleanly and exports the required types and function
2. Vision API prompts instruct Claude to return strict JSON per screen type (no freeform text)
3. Tauri capability allows opening a file dialog (prerequisite for 08-02 UI)
4. getApiKey() reused — zero new API key management code
</success_criteria>

<output>
After completion, create `.planning/phases/08-screenshot-ingestion/08-01-SUMMARY.md`
</output>
