---
phase: 03-player-tracking-and-records
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/desktop/src/lib/player-service.ts
  - apps/desktop/src/store/player-store.ts
  - apps/desktop/src/store/index.ts
  - apps/desktop/src/store/navigation-store.ts
  - apps/desktop/src/pages/RosterPage.tsx
  - apps/desktop/src/components/AddPlayerModal.tsx
  - apps/desktop/src/components/EditPlayerModal.tsx
  - apps/desktop/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can navigate to the Roster page from the dashboard"
    - "User can add a player with name, position, recruiting stars, home state, class year, and jersey number"
    - "User can see all active players listed on the Roster page grouped or filterable by position"
    - "User can edit an existing player's attributes"
    - "User can delete a player from the roster"
    - "User can navigate back to the dashboard from the Roster page"
  artifacts:
    - path: "apps/desktop/src/lib/player-service.ts"
      provides: "Player CRUD service functions"
      exports: ["createPlayer", "getPlayersByDynasty", "getPlayer", "updatePlayer", "deletePlayer"]
    - path: "apps/desktop/src/store/player-store.ts"
      provides: "Zustand store for player state"
      exports: ["usePlayerStore"]
    - path: "apps/desktop/src/store/navigation-store.ts"
      provides: "Simple page navigation state"
      exports: ["useNavigationStore"]
    - path: "apps/desktop/src/pages/RosterPage.tsx"
      provides: "Full roster management page"
      min_lines: 80
    - path: "apps/desktop/src/components/AddPlayerModal.tsx"
      provides: "Modal for adding new players"
      min_lines: 60
  key_links:
    - from: "apps/desktop/src/App.tsx"
      to: "apps/desktop/src/store/navigation-store.ts"
      via: "useNavigationStore currentPage"
      pattern: "currentPage.*roster"
    - from: "apps/desktop/src/pages/RosterPage.tsx"
      to: "apps/desktop/src/store/player-store.ts"
      via: "usePlayerStore hook"
      pattern: "usePlayerStore"
    - from: "apps/desktop/src/store/player-store.ts"
      to: "apps/desktop/src/lib/player-service.ts"
      via: "service function calls"
      pattern: "import.*player-service"
---

<objective>
Create the player roster foundation: CRUD service, Zustand store, navigation system, and a Roster page where users can add, view, edit, and delete players.

Purpose: This is the data and UI foundation that all player tracking features build on. Without players in the system, there are no stats to log, no career totals to compute, and no Legacy Cards to generate.

Output: Working Roster page accessible from the dashboard with full player CRUD.
</objective>

<execution_context>
@/Users/chanmoore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chanmoore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Source files for established patterns:
@apps/desktop/src/lib/game-service.ts
@apps/desktop/src/store/game-store.ts
@apps/desktop/src/App.tsx
@apps/desktop/src/pages/DashboardPage.tsx
@packages/core-types/src/player.ts
@packages/core-types/src/sport-config.ts
@packages/db/src/dynasty-db.ts
@packages/sport-configs/src/cfb.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Player service, player store, and navigation store</name>
  <files>
    apps/desktop/src/lib/player-service.ts
    apps/desktop/src/store/player-store.ts
    apps/desktop/src/store/navigation-store.ts
    apps/desktop/src/store/index.ts
  </files>
  <action>
    **player-service.ts** — Follow the exact pattern from game-service.ts:
    - `createPlayer(input: Omit<Player, 'id' | 'createdAt' | 'updatedAt'>): Promise<Player>` — uses generateId(), sets createdAt/updatedAt to Date.now(), calls db.players.add()
    - `getPlayersByDynasty(dynastyId: string): Promise<Player[]>` — query db.players.where('dynastyId').equals(dynastyId), sort by lastName ascending
    - `getPlayer(id: string): Promise<Player | undefined>` — db.players.get(id)
    - `updatePlayer(id: string, updates: Partial<Omit<Player, 'id' | 'dynastyId' | 'createdAt'>>): Promise<void>` — db.players.update(id, { ...updates, updatedAt: Date.now() })
    - `deletePlayer(id: string): Promise<void>` — also delete all playerSeasons where playerId === id (db.playerSeasons.where('playerId').equals(id).delete()), then db.players.delete(id)

    **player-store.ts** — Follow the exact pattern from game-store.ts:
    - State: `players: Player[]`, `loading: boolean`, `error: string | null`
    - Actions: `loadPlayers(dynastyId: string)`, `addPlayer(input)`, `updatePlayer(id, updates)`, `deletePlayer(id)`, `clearError()`
    - Every mutation reloads the full player list (reload-after-mutation pattern)
    - loadPlayers calls getPlayersByDynasty from the service

    **navigation-store.ts** — Simple page state (no router library needed):
    - State: `currentPage: 'dashboard' | 'roster' | 'player-profile' | 'legends'`, `pageParams: Record<string, string>` (for passing playerId etc.)
    - Actions: `navigate(page, params?)`, `goToDashboard()`, `goToRoster()`, `goToPlayerProfile(playerId: string)`, `goToLegends()`
    - Default currentPage: 'dashboard'

    **store/index.ts** — Add exports for usePlayerStore and useNavigationStore alongside existing exports.
  </action>
  <verify>
    Run `pnpm run build` from the apps/desktop directory (or `pnpm exec turbo build` from root). TypeScript compilation must pass with zero errors. Verify that player-service.ts exports 5 functions, player-store.ts exports usePlayerStore, and navigation-store.ts exports useNavigationStore.
  </verify>
  <done>
    player-service.ts has CRUD + cascade-delete for playerSeasons. player-store.ts follows the reload-after-mutation pattern. navigation-store.ts provides page switching without a router library. All three compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Roster page with Add/Edit player modals and navigation wiring</name>
  <files>
    apps/desktop/src/pages/RosterPage.tsx
    apps/desktop/src/components/AddPlayerModal.tsx
    apps/desktop/src/components/EditPlayerModal.tsx
    apps/desktop/src/App.tsx
    apps/desktop/src/pages/DashboardPage.tsx
  </files>
  <action>
    **App.tsx** — Replace the simple ternary with navigation-store-driven routing:
    ```
    const activeDynasty = useDynastyStore(s => s.activeDynasty);
    const currentPage = useNavigationStore(s => s.currentPage);

    if (!activeDynasty) return <LauncherPage />;

    switch (currentPage) {
      case 'roster': return <RosterPage />;
      case 'player-profile': return <PlayerProfilePage />;  // placeholder — built in Plan 02
      case 'legends': return <LegendsPage />;  // placeholder — built in Plan 03
      default: return <DashboardPage />;
    }
    ```
    For pages not yet built (player-profile, legends), render a simple placeholder div with text like "Coming soon" that navigates back to dashboard on click. Import lazily as needed.

    **DashboardPage.tsx** — Add a "Roster" button in the Actions panel (alongside Log Game and End Season):
    ```tsx
    <button onClick={() => useNavigationStore.getState().goToRoster()}
      className="w-full px-4 py-2.5 bg-gray-700 hover:bg-gray-600 ...">
      Manage Roster
    </button>
    ```

    **AddPlayerModal.tsx** — Modal for creating a new player:
    - Form fields: firstName (text), lastName (text), position (select from sport config positions), jerseyNumber (number 0-99), recruitingStars (select 1-5, optional), homeState (text, optional), homeCity (text, optional), classYear (select from sport config classYears, optional), height (text like "6'2\"", optional), weight (number, optional)
    - Get sport config positions and classYears from the active dynasty's sport via `getSportConfig(activeDynasty.sport)` from @dynasty-os/sport-configs
    - On submit: call usePlayerStore.getState().addPlayer({ dynastyId, firstName, lastName, position, status: 'active', ... })
    - Modal pattern: same as LogGameModal (isOpen/onClose props, overlay + centered card, gray-900 bg)
    - Required fields: firstName, lastName, position. All others optional.

    **EditPlayerModal.tsx** — Same form as AddPlayerModal but pre-filled with existing player data:
    - Props: isOpen, onClose, player (Player object)
    - On submit: call usePlayerStore.getState().updatePlayer(player.id, updates)
    - Same field layout, same modal pattern

    **RosterPage.tsx** — Full roster management page:
    - Header: same style as DashboardPage (dynasty name, sport badge, dynasty switcher)
    - Add a "Back to Dashboard" button/link in the header using useNavigationStore.getState().goToDashboard()
    - "Add Player" button that opens AddPlayerModal
    - Player list: table or card grid showing all active players for the dynasty
      - Columns: jersey number, name (first + last), position, class year, recruiting stars (as star icons or number), status
      - Sort by position group then by lastName
      - Click a row to open EditPlayerModal
      - Delete button per row with confirmation (window.confirm is fine)
    - Position filter: dropdown to filter by position (all positions from sport config + "All")
    - Status filter: "Active" / "Departed" / "All" toggle
    - Load players on mount via usePlayerStore.getState().loadPlayers(activeDynasty.id)
    - Use the Dashboard single-subscriber pattern: RosterPage subscribes to stores and passes props to children
    - Tailwind styling consistent with DashboardPage: bg-gray-900, bg-gray-800 cards, text-white, text-gray-400 labels
  </action>
  <verify>
    Run `pnpm run build` from root. Zero TypeScript errors. Manually verify (via `pnpm run dev` in apps/desktop and `pnpm tauri dev` or just Vite dev server on port 1420):
    1. Dashboard shows "Manage Roster" button
    2. Clicking it navigates to Roster page
    3. Roster page shows "Add Player" button and "Back to Dashboard" link
    4. Add Player modal opens with correct fields and dropdowns matching sport config
    5. Adding a player shows it in the roster list
    6. Clicking a player opens Edit modal with pre-filled data
    7. Editing a player reflects changes in the list
    8. Deleting a player removes it from the list
    9. Position and status filters work
  </verify>
  <done>
    User can navigate between Dashboard and Roster. User can add, view, edit, filter, and delete players. All form fields match the Player type and sport config (positions, classYears). Navigation works bidirectionally.
  </done>
</task>

</tasks>

<verification>
- `pnpm run build` passes from repo root (Turbo)
- Player CRUD works end-to-end through UI
- Navigation between Dashboard and Roster is bidirectional
- Position dropdown values come from sport config, not hardcoded
- Deleting a player also deletes their playerSeasons (cascade)
- Empty roster state shows helpful message
</verification>

<success_criteria>
1. Roster page is accessible from dashboard via "Manage Roster" button
2. User can add a player with all required fields (name, position) and optional fields (stars, home state, class year, jersey, height, weight)
3. Players display in a filterable list by position and status
4. Edit and delete operations work correctly
5. Navigation store enables page switching without a router library
6. Build compiles with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-player-tracking-and-records/03-01-SUMMARY.md`
</output>
