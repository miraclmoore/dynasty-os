---
phase: 10-infrastructure-foundation
plan: 04
type: execute
wave: 2
depends_on:
  - 10-02
files_modified:
  - apps/desktop/src/store/toast-store.ts
  - apps/desktop/src/store/filter-store.ts
  - apps/desktop/src/store/undo-store.ts
  - apps/desktop/src/store/ai-queue-store.ts
  - apps/desktop/src/store/index.ts
  - apps/desktop/src/App.tsx
autonomous: true
requirements:
  - INFRA-GATE-3
  - INFRA-GATE-5

must_haves:
  truths:
    - "ToastStore, FilterStore, UndoStore, and AiQueueStore are callable from any component after App.tsx mounts"
    - "sonner <Toaster /> is mounted in App.tsx so future toast() calls render without any additional setup"
    - "A keydown listener for Cmd+K / Ctrl+K is registered in App.tsx with the Tauri cold-launch focus fix"
    - "Async AI job queue pattern is scaffolded — enqueueAiJob() adds a job to the pendingAiJobs queue without blocking the caller"
  artifacts:
    - path: "apps/desktop/src/store/toast-store.ts"
      provides: "useToastStore with success(), error(), info() wrappers around sonner toast()"
      exports: ["useToastStore"]
    - path: "apps/desktop/src/store/filter-store.ts"
      provides: "useFilterStore with setFilter(), getFilters(), clearFilters() for session-scoped page filter persistence"
      exports: ["useFilterStore"]
    - path: "apps/desktop/src/store/undo-store.ts"
      provides: "useUndoStore with pushUndo(), undo(), clearHistory() using DB-level UndoableOperation descriptor pattern"
      exports: ["useUndoStore", "UndoableOperation"]
    - path: "apps/desktop/src/store/ai-queue-store.ts"
      provides: "useAiQueueStore with enqueueAiJob(), pendingAiJobs state, AiJob type"
      exports: ["useAiQueueStore", "AiJob"]
    - path: "apps/desktop/src/App.tsx"
      provides: "<Toaster /> mounted; hidden input autofocus fix; Cmd+K keydown listener stub"
  key_links:
    - from: "apps/desktop/src/App.tsx"
      to: "sonner"
      via: "import { Toaster } from 'sonner'"
      pattern: "<Toaster"
    - from: "apps/desktop/src/store/toast-store.ts"
      to: "sonner"
      via: "import { toast } from 'sonner'"
      pattern: "import.*sonner"
    - from: "apps/desktop/src/store/undo-store.ts"
      to: "packages/db/src/dynasty-db.ts"
      via: "import { db } from '@dynasty-os/db' in undo() implementation"
      pattern: "db\\[op\\.table\\]"
---

<objective>
Scaffold four global Zustand stores (ToastStore, FilterStore, UndoStore, AiQueueStore) and wire them into App.tsx with the sonner Toaster component and Cmd+K keyboard listener stub.

Purpose: Phase 11 QOL features (toasts, undo, filters, command palette) depend on these stores being callable from day one. Phase 13 AI features depend on the async job queue pattern. Phase 10 wires the scaffolds — Phase 11 populates them with real operations.
Output: 4 new store files; store/index.ts updated; App.tsx updated with Toaster + keyboard listener.
</objective>

<execution_context>
@/Users/chanmoore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chanmoore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/10-infrastructure-foundation/10-02-SUMMARY.md
@apps/desktop/src/store/index.ts
@apps/desktop/src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold ToastStore, FilterStore, UndoStore, and AiQueueStore</name>
  <files>apps/desktop/src/store/toast-store.ts</files>
  <files>apps/desktop/src/store/filter-store.ts</files>
  <files>apps/desktop/src/store/undo-store.ts</files>
  <files>apps/desktop/src/store/ai-queue-store.ts</files>
  <files>apps/desktop/src/store/index.ts</files>
  <action>
Create 4 store files following the existing store pattern (Zustand create, typed interface, named export).

**`apps/desktop/src/store/toast-store.ts`:**
```typescript
import { create } from 'zustand';
import { toast } from 'sonner';

interface ToastActions {
  success: (message: string, description?: string) => void;
  error: (message: string, description?: string) => void;
  info: (message: string) => void;
  loading: (message: string) => string | number;
  dismiss: (id?: string | number) => void;
}

export const useToastStore = create<ToastActions>(() => ({
  success: (message, description) => toast.success(message, { description }),
  error: (message, description) => toast.error(message, { description }),
  info: (message) => toast(message),
  loading: (message) => toast.loading(message),
  dismiss: (id) => toast.dismiss(id),
}));
```

**`apps/desktop/src/store/filter-store.ts`:**
```typescript
import { create } from 'zustand';

interface FilterState {
  filters: Record<string, Record<string, unknown>>;
}
interface FilterActions {
  setFilter: (page: string, key: string, value: unknown) => void;
  getFilters: (page: string) => Record<string, unknown>;
  clearFilters: (page: string) => void;
  clearAll: () => void;
}

export const useFilterStore = create<FilterState & FilterActions>((set, get) => ({
  filters: {},
  setFilter: (page, key, value) =>
    set((state) => ({
      filters: {
        ...state.filters,
        [page]: { ...(state.filters[page] ?? {}), [key]: value },
      },
    })),
  getFilters: (page) => get().filters[page] ?? {},
  clearFilters: (page) =>
    set((state) => {
      const next = { ...state.filters };
      delete next[page];
      return { filters: next };
    }),
  clearAll: () => set({ filters: {} }),
}));
```

**`apps/desktop/src/store/undo-store.ts`:**
Uses DB-level operation descriptor pattern (STATE.md decision) — NOT zundo snapshot middleware. zundo is installed but not used here.

```typescript
import { create } from 'zustand';
import { db } from '@dynasty-os/db';

export interface UndoableOperation {
  id: string;
  table: string;
  operation: 'delete' | 'update';
  recordId: string;
  snapshot: Record<string, unknown>;
  description: string;
  performedAt: number;
}

interface UndoState {
  history: UndoableOperation[];
}
interface UndoActions {
  pushUndo: (op: UndoableOperation) => void;
  undo: () => Promise<void>;
  clearHistory: () => void;
}

const MAX_HISTORY = 20;

export const useUndoStore = create<UndoState & UndoActions>((set, get) => ({
  history: [],
  pushUndo: (op) =>
    set((state) => ({
      history: [...state.history, op].slice(-MAX_HISTORY),
    })),
  undo: async () => {
    const { history } = get();
    if (history.length === 0) return;
    const last = history[history.length - 1];
    if (last.operation === 'delete') {
      // Restore deleted record
      await (db as any)[last.table].add(last.snapshot);
    } else if (last.operation === 'update') {
      // Restore prior state
      await (db as any)[last.table].put(last.snapshot);
    }
    set((state) => ({ history: state.history.slice(0, -1) }));
  },
  clearHistory: () => set({ history: [] }),
}));
```

**`apps/desktop/src/store/ai-queue-store.ts`:**
Standalone store per RESEARCH.md recommendation (not a slice of dynasty-store).

```typescript
import { create } from 'zustand';
import { v4 as uuidv4 } from 'uuid';

export interface AiJob {
  id: string;
  type: 'legacy-blurb' | 'season-narrative' | 'recruiting-grade' | 'journalist-blurb' | 'hot-seat' | 'dossier' | 'rival-prophecy' | 'obituary' | 'generational-arc' | 'what-if' | 'dna-report' | 'living-chronicle';
  payload: Record<string, unknown>;
  dynastyId: string;
  status: 'pending' | 'running' | 'done' | 'failed';
  enqueuedAt: number;
}

interface AiQueueState {
  pendingAiJobs: AiJob[];
}
interface AiQueueActions {
  enqueueAiJob: (job: Omit<AiJob, 'id' | 'status' | 'enqueuedAt'>) => void;
  updateJobStatus: (id: string, status: AiJob['status']) => void;
  clearCompleted: () => void;
}

export const useAiQueueStore = create<AiQueueState & AiQueueActions>((set) => ({
  pendingAiJobs: [],
  enqueueAiJob: (job) =>
    set((state) => ({
      pendingAiJobs: [
        ...state.pendingAiJobs,
        { ...job, id: uuidv4(), status: 'pending', enqueuedAt: Date.now() },
      ],
    })),
  updateJobStatus: (id, status) =>
    set((state) => ({
      pendingAiJobs: state.pendingAiJobs.map((j) =>
        j.id === id ? { ...j, status } : j
      ),
    })),
  clearCompleted: () =>
    set((state) => ({
      pendingAiJobs: state.pendingAiJobs.filter(
        (j) => j.status !== 'done' && j.status !== 'failed'
      ),
    })),
}));
```

Check the existing uuid import pattern in the codebase (other service files) to confirm `import { v4 as uuidv4 } from 'uuid'` is correct for this project.

**Update `apps/desktop/src/store/index.ts`** — add 4 new exports:
```typescript
export { useToastStore } from './toast-store';
export { useFilterStore } from './filter-store';
export { useUndoStore } from './undo-store';
export type { UndoableOperation } from './undo-store';
export { useAiQueueStore } from './ai-queue-store';
export type { AiJob } from './ai-queue-store';
```
  </action>
  <verify>
    <automated>cd /Users/chanmoore/dev/dynasty-os && pnpm --filter @dynasty-os/desktop build 2>&1 | grep -E "error TS|Error:" | head -10</automated>
    <manual>Confirm all 4 store files exist; store/index.ts exports all 4 new stores; no TypeScript errors</manual>
  </verify>
  <done>All 4 store files exist and compile cleanly; useToastStore, useFilterStore, useUndoStore, useAiQueueStore are exported from store/index.ts</done>
</task>

<task type="auto">
  <name>Task 2: Wire App.tsx — mount Toaster, hidden autofocus input, Cmd+K listener stub</name>
  <files>apps/desktop/src/App.tsx</files>
  <action>
Update `apps/desktop/src/App.tsx` with 3 additions:

1. **Import sonner Toaster:** Add `import { Toaster } from 'sonner';` at the top with other imports.

2. **Mount `<Toaster />`:** In the `App` component's return JSX, add `<Toaster richColors position="bottom-right" />` as a sibling inside the root div, alongside `<PageContent />` and `<TickerBar />`.

3. **Tauri cold-launch keyboard fix + Cmd+K listener stub:** Add a `useEffect` to the `App` component:
```typescript
import React, { useEffect, useRef } from 'react';
// ...

function App() {
  const hiddenInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    // Tauri WebView cold-launch fix: force focus into document body
    // so keydown listeners receive events on first launch without clicking
    // (STATE.md decision: "Ctrl+K autofocus fix")
    if (hiddenInputRef.current) {
      hiddenInputRef.current.focus();
      hiddenInputRef.current.blur();
    }

    // Cmd+K / Ctrl+K listener stub — opens command palette (Phase 11 QOL-04)
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'k' && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        // Command palette toggle — wired in Phase 11
        // console.log('Command palette trigger registered');
      }
    };
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, []);

  return (
    <div className="pb-10">
      {/* Hidden input forces keyboard focus into document on Tauri cold launch */}
      <input ref={hiddenInputRef} style={{ position: 'fixed', opacity: 0, pointerEvents: 'none', width: 0, height: 0 }} tabIndex={-1} readOnly aria-hidden="true" />
      <PageContent />
      <TickerBar />
      <Toaster richColors position="bottom-right" />
    </div>
  );
}
```

Make sure `useEffect` and `useRef` are imported from React. The existing `import React from 'react'` may need to change to `import React, { useEffect, useRef } from 'react'`.

The `<Toaster />` must be outside any conditional rendering — it is always mounted regardless of activeDynasty state, so `toast()` calls anywhere in the app (including on the LauncherPage) will render.
  </action>
  <verify>
    <automated>cd /Users/chanmoore/dev/dynasty-os && pnpm --filter @dynasty-os/desktop build 2>&1 | grep -E "error TS|Error:" | head -10</automated>
    <manual>Confirm App.tsx has Toaster import, Toaster mounted in JSX, useEffect with keydown listener, hidden input with ref; build passes</manual>
  </verify>
  <done>App.tsx compiles cleanly; Toaster is mounted unconditionally; keydown listener for Cmd+K is registered on document; Tauri cold-launch focus fix hidden input is present</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `pnpm --filter @dynasty-os/desktop build` exits 0 with no TypeScript errors
2. `grep "Toaster" apps/desktop/src/App.tsx` returns import and JSX usage
3. `grep "keydown" apps/desktop/src/App.tsx` returns listener registration
4. All 4 store files exist: `ls apps/desktop/src/store/{toast,filter,undo,ai-queue}-store.ts`
5. `grep "useToastStore\|useFilterStore\|useUndoStore\|useAiQueueStore" apps/desktop/src/store/index.ts` returns all 4
</verification>

<success_criteria>
- ToastStore wraps sonner toast() with success/error/info/loading/dismiss methods
- FilterStore holds session-scoped page filters in a nested Record map
- UndoStore uses DB-level UndoableOperation descriptor pattern (not zundo snapshot) with 20-item history limit
- AiQueueStore holds pendingAiJobs with enqueueAiJob() as fire-and-forget entry point
- App.tsx: Toaster mounted, Cmd+K listener registered, Tauri cold-launch focus fix applied
- All 4 stores exported from store/index.ts
- Desktop build passes
- INFRA-GATE-3: Async AI job queue (pendingAiJobs) in Zustand resolves saves in under 200ms (enqueueAiJob is synchronous — AI runs async)
- INFRA-GATE-5: ToastStore, FilterStore, and UndoStore are wired into App.tsx and callable from any component
</success_criteria>

<output>
After completion, create `.planning/phases/10-infrastructure-foundation/10-04-SUMMARY.md` following the summary template.
</output>
