---
phase: 11-qol-wins
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/desktop/src/store/dynasty-store.ts
  - apps/desktop/src/pages/RosterPage.tsx
  - apps/desktop/src/pages/LegendsPage.tsx
  - apps/desktop/src/pages/RecordsPage.tsx
  - apps/desktop/src/pages/DraftTrackerPage.tsx
  - apps/desktop/src/pages/TransferPortalPage.tsx
autonomous: true
requirements: [QOL-03]

must_haves:
  truths:
    - "After setting a position filter on RosterPage and navigating away, returning shows the same filter active"
    - "After setting a status filter on RosterPage and navigating away, returning shows the same filter active"
    - "Switching dynasties resets all filter selections (no stale filters from previous dynasty)"
    - "Filter state lives only for the session — not persisted across app restarts"
  artifacts:
    - path: "apps/desktop/src/store/dynasty-store.ts"
      provides: "switchDynasty calls useFilterStore.getState().clearAll()"
    - path: "apps/desktop/src/pages/RosterPage.tsx"
      provides: "positionFilter and statusFilter read from and write to useFilterStore"
    - path: "apps/desktop/src/pages/LegendsPage.tsx"
      provides: "position/era filters wired to useFilterStore"
    - path: "apps/desktop/src/pages/RecordsPage.tsx"
      provides: "stat-category or season selector wired to useFilterStore"
    - path: "apps/desktop/src/pages/DraftTrackerPage.tsx"
      provides: "year selector wired to useFilterStore"
    - path: "apps/desktop/src/pages/TransferPortalPage.tsx"
      provides: "season selector wired to useFilterStore"
  key_links:
    - from: "apps/desktop/src/pages/RosterPage.tsx"
      to: "apps/desktop/src/store/filter-store.ts"
      via: "getFilters('roster') on mount; setFilter('roster', key, val) on change"
      pattern: "useFilterStore\\.getState\\(\\)\\.getFilters\\('roster'\\)"
    - from: "apps/desktop/src/store/dynasty-store.ts"
      to: "apps/desktop/src/store/filter-store.ts"
      via: "useFilterStore.getState().clearAll() in switchDynasty and setActiveDynasty"
      pattern: "clearAll"
---

<objective>
Wire filter persistence across all pages with user-facing filter controls. On each filtered page, read saved filter values from useFilterStore on mount and write back on every change. Add clearAll() to dynasty switch to prevent stale cross-dynasty filters.

Purpose: QOL-03 makes the app feel responsive — coaches should not lose their filter context when clicking into a player profile and coming back. The useFilterStore is already built (Phase 10); this plan connects it to each page's local useState.

Output: Modified page files that initialize filter state from useFilterStore and sync back on change; dynasty-store that resets filters on switch.
</objective>

<execution_context>
@/Users/chanmoore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chanmoore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-qol-wins/11-RESEARCH.md
@apps/desktop/src/store/filter-store.ts
@apps/desktop/src/store/dynasty-store.ts
@apps/desktop/src/pages/RosterPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add clearAll() to dynasty switch + wire RosterPage filter persistence</name>
  <files>
    apps/desktop/src/store/dynasty-store.ts
    apps/desktop/src/pages/RosterPage.tsx
  </files>
  <action>
**dynasty-store.ts:**

Add `import { useFilterStore } from './filter-store';` at the top.

In `switchDynasty`:
```typescript
switchDynasty: (dynasty: Dynasty) => {
  useFilterStore.getState().clearAll();
  set({ activeDynasty: dynasty });
},
```

In `setActiveDynasty` (called from DynastySwitcher and LauncherPage):
```typescript
setActiveDynasty: (dynasty: Dynasty | null) => {
  useFilterStore.getState().clearAll();
  set({ activeDynasty: dynasty });
},
```

This satisfies Pitfall 5 from RESEARCH.md — stale filters after dynasty switch.

**RosterPage.tsx:**

Add `import { useFilterStore } from '../store/filter-store';` near the top (after existing imports).

Replace the two `useState` initializations for filters with filter-store-aware versions. Find:
```typescript
const [positionFilter, setPositionFilter] = useState<string>('All');
const [statusFilter, setStatusFilter] = useState<StatusFilter>('active');
```

Replace with:
```typescript
const PAGE_KEY = 'roster';
const _savedFilters = useFilterStore.getState().getFilters(PAGE_KEY);
const [positionFilter, setPositionFilterState] = useState<string>(
  (_savedFilters['position'] as string) ?? 'All'
);
const [statusFilter, setStatusFilterState] = useState<StatusFilter>(
  (_savedFilters['status'] as StatusFilter) ?? 'active'
);
```

Add setter wrappers after the useState declarations:
```typescript
const setPositionFilter = (val: string) => {
  setPositionFilterState(val);
  useFilterStore.getState().setFilter(PAGE_KEY, 'position', val);
};
const setStatusFilter = (val: StatusFilter) => {
  setStatusFilterState(val);
  useFilterStore.getState().setFilter(PAGE_KEY, 'status', val);
};
```

Now wherever `setPositionFilter(...)` and `setStatusFilter(...)` are called in the JSX (inside onChange handlers), they will both update local state AND persist to the filter store. No JSX changes needed since the setter names are identical — only the declaration block changes.

Note: `useFilterStore.getState().getFilters()` is called once at component declaration time (not inside useEffect) so it reads the current in-memory store value synchronously. This is correct — useFilterStore is an in-memory Zustand store and `getState()` is synchronous.
  </action>
  <verify>
    <automated>cd /Users/chanmoore/dev/dynasty-os && pnpm --filter @dynasty-os/desktop build 2>&1 | tail -20</automated>
    <manual>In the app: set position filter to "QB" on RosterPage, navigate to a player profile, navigate back to Roster — confirm filter is still "QB". Switch dynasty — confirm filter resets to "All".</manual>
  </verify>
  <done>dynasty-store.switchDynasty and setActiveDynasty call clearAll(); RosterPage reads/writes positionFilter and statusFilter from useFilterStore; build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Wire filter persistence into LegendsPage, RecordsPage, DraftTrackerPage, TransferPortalPage</name>
  <files>
    apps/desktop/src/pages/LegendsPage.tsx
    apps/desktop/src/pages/RecordsPage.tsx
    apps/desktop/src/pages/DraftTrackerPage.tsx
    apps/desktop/src/pages/TransferPortalPage.tsx
  </files>
  <action>
Apply the same filter persistence pattern from Task 1 to each additional page. For each page:
1. Add `import { useFilterStore } from '../store/filter-store';`
2. Identify the local useState filter variables
3. Replace with filter-store-aware initialization using `useFilterStore.getState().getFilters(PAGE_KEY)`
4. Wrap setters to call `useFilterStore.getState().setFilter(PAGE_KEY, key, val)` on each change

Read the current file content before editing each page to identify the exact filter variable names and their types.

**LegendsPage.tsx** — PAGE_KEY: `'legends'`. Find filter state for position/era/award if present. Apply the same wrapper pattern.

**RecordsPage.tsx** — PAGE_KEY: `'records'`. Find any season/stat-category selector state. Apply wrapper pattern.

**DraftTrackerPage.tsx** — PAGE_KEY: `'draft-tracker'`. Find the year/era selector state. Apply wrapper pattern.

**TransferPortalPage.tsx** — PAGE_KEY: `'transfer-portal'`. Find the season selector state. Apply wrapper pattern.

For any page that has no filter state (only display), skip it — do not add artificial filters.

Important: Use `useFilterStore.getState().getFilters(PAGE_KEY)` (synchronous, no hook) at the component declaration level, not inside useEffect. The filter store is pure in-memory Zustand — this is always safe.
  </action>
  <verify>
    <automated>cd /Users/chanmoore/dev/dynasty-os && pnpm --filter @dynasty-os/desktop build 2>&1 | tail -20</automated>
    <manual>Set a position filter on LegendsPage, navigate away, return — confirm filter persists. Repeat for any year selector on DraftTrackerPage/TransferPortalPage.</manual>
  </verify>
  <done>All pages with filter state read from and write to useFilterStore; TypeScript build passes clean; no new errors.</done>
</task>

</tasks>

<verification>
Run `pnpm --filter @dynasty-os/desktop build` — no errors.
Run `grep -rn "useFilterStore" apps/desktop/src/` — present in dynasty-store.ts, RosterPage.tsx, LegendsPage.tsx (if it had filters), RecordsPage.tsx, DraftTrackerPage.tsx, TransferPortalPage.tsx.
Run `grep -n "clearAll" apps/desktop/src/store/dynasty-store.ts` — present in both switchDynasty and setActiveDynasty.
</verification>

<success_criteria>
1. RosterPage position and status filters survive navigation within the session.
2. Switching dynasties resets all filter state via clearAll().
3. All pages with user-visible filter controls are wired to useFilterStore.
4. TypeScript build passes clean.
</success_criteria>

<output>
After completion, create `.planning/phases/11-qol-wins/11-02-SUMMARY.md`
</output>
