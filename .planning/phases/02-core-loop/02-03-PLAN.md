---
phase: 02-core-loop
plan: "03"
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - apps/desktop/src/components/LogGameModal.tsx
  - apps/desktop/src/components/TeamSelect.tsx
  - apps/desktop/src/components/SeasonEndModal.tsx
  - apps/desktop/src/pages/DashboardPage.tsx
autonomous: false

must_haves:
  truths:
    - "User can open Log Game modal from dashboard and log a game result in under 60 seconds"
    - "Opponent dropdown shows all teams from sport config, auto-populates conference on selection"
    - "Selecting a team auto-populates the opponent conference field without typing"
    - "Week, game type, and home/away fields use dropdown selectors (not free text)"
    - "Score fields accept numeric input for team and opponent scores"
    - "Result (W/L/T) auto-calculates from scores — user does not manually select it"
    - "After logging a game, dashboard record and recent activity update immediately"
    - "User can open Season End modal and record final ranking, bowl game, and bowl result"
    - "Season-end data persists and shows on dashboard"
  artifacts:
    - path: "apps/desktop/src/components/LogGameModal.tsx"
      provides: "Game entry modal with all fields and smart dropdowns"
      min_lines: 80
    - path: "apps/desktop/src/components/TeamSelect.tsx"
      provides: "Searchable team dropdown that auto-populates conference"
      min_lines: 40
    - path: "apps/desktop/src/components/SeasonEndModal.tsx"
      provides: "Season-end data entry modal (ranking, bowl, playoff)"
      min_lines: 50
  key_links:
    - from: "apps/desktop/src/components/LogGameModal.tsx"
      to: "apps/desktop/src/store/game-store.ts"
      via: "logGame action called on form submit"
      pattern: "useGameStore.*logGame"
    - from: "apps/desktop/src/components/LogGameModal.tsx"
      to: "apps/desktop/src/components/TeamSelect.tsx"
      via: "TeamSelect used for opponent field"
      pattern: "TeamSelect"
    - from: "apps/desktop/src/components/TeamSelect.tsx"
      to: "@dynasty-os/sport-configs"
      via: "getSportConfig to load teams and conferences"
      pattern: "getSportConfig"
    - from: "apps/desktop/src/components/SeasonEndModal.tsx"
      to: "apps/desktop/src/store/season-store.ts"
      via: "updateSeason action called on submit"
      pattern: "useSeasonStore.*updateSeason"
    - from: "apps/desktop/src/pages/DashboardPage.tsx"
      to: "apps/desktop/src/components/LogGameModal.tsx"
      via: "Log Game button opens modal"
      pattern: "logGameOpen.*LogGameModal"
---

<objective>
Build the game entry form with smart team dropdowns and the season-end data modal — the two
primary data entry flows in the core loop.

Purpose: This is how data gets INTO the system. Without smart entry, logging games is tedious
and error-prone. Team auto-populate from sport config eliminates typing and ensures data consistency.

Output: LogGameModal with TeamSelect smart dropdown, SeasonEndModal for end-of-season data,
and DashboardPage updated to wire both modals.
</objective>

<execution_context>
@/Users/chanmoore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chanmoore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md

# Data layer (from Plan 02-01)
@apps/desktop/src/store/season-store.ts
@apps/desktop/src/store/game-store.ts
@apps/desktop/src/lib/game-service.ts

# Dashboard (from Plan 02-02 — will have been built by execution time)
@apps/desktop/src/pages/DashboardPage.tsx

# Sport config for team/conference data
@packages/sport-configs/src/index.ts
@packages/core-types/src/sport-config.ts

# Types
@packages/core-types/src/game.ts
@packages/core-types/src/season.ts

# Existing modal pattern
@apps/desktop/src/components/CreateDynastyModal.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TeamSelect and LogGameModal components</name>
  <files>
    apps/desktop/src/components/TeamSelect.tsx
    apps/desktop/src/components/LogGameModal.tsx
  </files>
  <action>
    Create `apps/desktop/src/components/TeamSelect.tsx`:

    A searchable dropdown for selecting an opponent team from the sport config.

    Props:
    - `sport: SportType` — determines which sport config to load
    - `value: string` — currently selected team name
    - `onChange: (teamName: string, conference: string) => void` — called with BOTH team name AND conference
    - `placeholder?: string` — defaults to "Select opponent..."

    Implementation:
    - Call `getSportConfig(sport)` to get the TeamInfo[] array
    - Render a text input with autocomplete-style dropdown
    - As user types, filter teams whose name includes the search text (case-insensitive)
    - Show filtered teams in a dropdown list below the input, grouped by conference
    - Each team option shows: "{team.name}" with conference in text-gray-500
    - On selection: call onChange with team.name and team.conference
    - Close dropdown on selection or when clicking outside (useRef + onBlur with small delay)
    - If no matches: show "No teams found" in dropdown
    - Style: bg-gray-700 input, bg-gray-800 dropdown, hover:bg-gray-700 on options, rounded-lg

    Create `apps/desktop/src/components/LogGameModal.tsx`:

    Props:
    - `isOpen: boolean`
    - `onClose: () => void`
    - `dynastyId: string`
    - `seasonId: string`
    - `sport: SportType`

    Modal overlay (fixed inset-0, bg-black/50 backdrop, centered white card on bg-gray-800).
    Follow the existing CreateDynastyModal.tsx pattern for modal structure.

    Form fields (all in a single form):
    1. **Week** — `<select>` dropdown with options 1-20 (covers regular season + postseason).
       Default to the next available week: max(existing game weeks) + 1, or 1 if no games.
       Import useGameStore to read current games for this calculation.
    2. **Opponent** — `<TeamSelect>` component. When team is selected, auto-set opponentConference
       state variable (not rendered as a visible field, stored internally).
    3. **Home/Away** — `<select>` with options: "Home", "Away", "Neutral". Values: 'home', 'away', 'neutral'.
    4. **Game Type** — `<select>` with options matching GameType: 'regular', 'conference', 'bowl', 'playoff', 'exhibition'.
       Display labels: "Regular Season", "Conference Game", "Bowl Game", "Playoff", "Exhibition".
    5. **Our Score** — `<input type="number" min="0">`, labeled "Your Score" or the dynasty team name
    6. **Their Score** — `<input type="number" min="0">`, labeled "Opponent Score"
    7. **Opponent Ranking** — `<input type="number" min="1" max="25">` optional, labeled "#Rank (optional)"
    8. **Overtime** — `<input type="checkbox">` labeled "Overtime?"
    9. **Notes** — `<textarea>` optional, 2 rows

    **Auto-calculate result:** When both scores are entered, derive result:
    - teamScore > opponentScore → 'W'
    - teamScore < opponentScore → 'L'
    - teamScore === opponentScore → 'T'
    Show the derived result as a colored badge next to the scores (green W, red L, gray T).

    **Submit handler:**
    Build a Game object (minus id/timestamps) from form state. Call:
    ```
    const gameStore = useGameStore.getState();
    await gameStore.logGame({ dynastyId, seasonId, week, opponent, ... });
    ```
    After successful save, also reload the season store to reflect updated W/L:
    ```
    await useSeasonStore.getState().loadSeasons(dynastyId);
    ```
    Then call onClose().

    **Validation:** Require: opponent (non-empty), both scores (>= 0), week, gameType, homeAway.
    Disable submit button until all required fields are filled.

    **Cancel:** Button that calls onClose(). Also close on backdrop click and Escape key.

    Style: Match CreateDynastyModal styling. Dark theme, bg-gray-800 modal body, bg-gray-700 inputs,
    blue-600 submit button, gray-600 cancel button.
  </action>
  <verify>
    Run `pnpm exec tsc --noEmit -p apps/desktop/tsconfig.json` — no type errors.
    Verify TeamSelect imports getSportConfig correctly.
    Verify LogGameModal builds the correct Game input shape for the game store.
  </verify>
  <done>
    TeamSelect renders searchable team dropdown from sport config, returns team name + conference on selection.
    LogGameModal has all game fields with smart defaults, auto-calculates result from scores,
    submits via game store, and triggers season store reload.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SeasonEndModal and wire modals into DashboardPage</name>
  <files>
    apps/desktop/src/components/SeasonEndModal.tsx
    apps/desktop/src/pages/DashboardPage.tsx
  </files>
  <action>
    Create `apps/desktop/src/components/SeasonEndModal.tsx`:

    Props:
    - `isOpen: boolean`
    - `onClose: () => void`
    - `seasonId: string`
    - `dynastyId: string`
    - `currentSeason: Season | null`

    Modal structure matching CreateDynastyModal pattern.

    Form fields:
    1. **Final AP/CFP Ranking** — `<input type="number" min="1" max="25">` optional.
       Pre-fill with currentSeason.finalRanking if it exists.
    2. **Bowl Game** — `<input type="text" placeholder="e.g., Rose Bowl">` optional.
       Pre-fill with currentSeason.bowlGame if it exists.
    3. **Bowl Result** — `<select>` with options: "Win" ('W'), "Loss" ('L'), or "N/A" (undefined).
       Only show/enable if bowl game name is filled in. Pre-fill from currentSeason.bowlResult.
    4. **Playoff Result** — `<input type="text" placeholder="e.g., National Champion, Semifinal loss">` optional.
       Pre-fill from currentSeason.playoffResult.
    5. **Season Notes** — `<textarea>` optional, 3 rows. Pre-fill from currentSeason.notes.

    **Submit handler:**
    Call `useSeasonStore.getState().updateSeason(seasonId, { finalRanking, bowlGame, bowlResult, playoffResult, notes })`.
    Only include fields that have values (don't overwrite existing data with undefined unless user clears them).
    After save, call onClose().

    **Update DashboardPage.tsx:**
    1. Import LogGameModal and SeasonEndModal.
    2. Add state: `const [logGameOpen, setLogGameOpen] = useState(false)`
       and `const [seasonEndOpen, setSeasonEndOpen] = useState(false)`.
    3. Replace any placeholder modal content with the real modal components:
       ```tsx
       <LogGameModal
         isOpen={logGameOpen}
         onClose={() => { setLogGameOpen(false); /* reload data */ }}
         dynastyId={activeDynasty.id}
         seasonId={activeSeason.id}
         sport={activeDynasty.sport}
       />
       <SeasonEndModal
         isOpen={seasonEndOpen}
         onClose={() => { setSeasonEndOpen(false); /* reload data */ }}
         seasonId={activeSeason.id}
         dynastyId={activeDynasty.id}
         currentSeason={activeSeason}
       />
       ```
    4. Wire the "Log Game" button onClick to `setLogGameOpen(true)`.
    5. Wire the "End Season" button onClick to `setSeasonEndOpen(true)`.
    6. After modal close, reload both stores:
       ```tsx
       const handleLogGameClose = async () => {
         setLogGameOpen(false);
         if (activeDynasty) {
           await seasonStore.loadSeasons(activeDynasty.id);
         }
         if (activeSeason) {
           await gameStore.loadGames(activeSeason.id);
         }
       };
       ```
  </action>
  <verify>
    Run `pnpm exec tsc --noEmit -p apps/desktop/tsconfig.json` — no type errors.
    Verify DashboardPage imports and renders both modals.
    Verify modal open/close state is correctly wired to buttons.
  </verify>
  <done>
    SeasonEndModal allows recording final ranking, bowl game, bowl result, playoff result, and notes.
    DashboardPage renders LogGameModal and SeasonEndModal with correct open/close wiring.
    After closing either modal, dashboard data refreshes to show updated records.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete game entry flow: Log Game modal with smart team dropdown (opponent auto-populates
    conference), score entry with auto-calculated result, and Season End modal for final rankings
    and bowl data. Dashboard wired to open both modals and refresh after close.
  </what-built>
  <how-to-verify>
    1. Run `pnpm run dev` from apps/desktop
    2. Select or create a dynasty
    3. Dashboard should show grid layout with widgets and "Log Game" / "End Season" buttons
    4. Click "Log Game":
       - Type a team name in the opponent field — dropdown should filter and show matching teams
       - Select a team — verify you did NOT need to type the conference
       - Set week, home/away, game type
       - Enter scores — verify W/L/T badge auto-appears
       - Submit — verify the game appears in Recent Results and record updates (e.g., 1-0)
    5. Log 2-3 more games (including at least one conference game)
       - Verify overall record updates correctly
       - Verify conference record shows when conference games exist
    6. Click "End Season":
       - Enter a final ranking, bowl game name, bowl result
       - Submit — verify ranking badge appears on dashboard
    7. Verify the entire flow takes under 60 seconds per game entry
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit -p apps/desktop/tsconfig.json` — zero errors
2. `pnpm run build` from repo root succeeds
3. Log Game modal opens, team dropdown filters from sport config
4. Selecting team auto-populates conference (INGST-01)
5. All dropdowns use select/autocomplete — no free text for structured fields (INGST-02)
6. Result auto-calculates from scores
7. After logging a game, dashboard record and recent activity update immediately (SEAS-02, SEAS-03)
8. Season End modal saves final ranking, bowl data, and notes (SEAS-04)
</verification>

<success_criteria>
- DASH-02: Log Game button visible and functional on dashboard
- SEAS-01: User can log game with opponent, score, home/away, game type, week
- SEAS-04: User can record season-end data (final ranking, bowl/playoff outcome)
- INGST-01: Team selection auto-populates conference
- INGST-02: Smart dropdowns for team, game type, home/away, week fields
- Game entry takes under 60 seconds with smart defaults
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-loop/02-03-SUMMARY.md`
</output>
