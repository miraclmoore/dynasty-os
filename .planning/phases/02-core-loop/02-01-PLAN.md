---
phase: 02-core-loop
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/desktop/src/lib/season-service.ts
  - apps/desktop/src/lib/game-service.ts
  - apps/desktop/src/store/season-store.ts
  - apps/desktop/src/store/game-store.ts
  - apps/desktop/src/store/index.ts
autonomous: true

must_haves:
  truths:
    - "Creating a season via season-service persists it in Dexie and is retrievable by dynastyId"
    - "Creating a game via game-service persists it and auto-recalculates the parent season W/L and conference W/L"
    - "Deleting a game triggers season record recalculation"
    - "Season store exposes activeSeason and seasons array, reloads after every mutation"
    - "Game store exposes games array for active season, reloads and recalculates after every mutation"
  artifacts:
    - path: "apps/desktop/src/lib/season-service.ts"
      provides: "Season CRUD + getCurrentSeason helper"
      exports: ["createSeason", "getSeasons", "getSeasonsByDynasty", "getSeason", "updateSeason", "getCurrentSeason"]
    - path: "apps/desktop/src/lib/game-service.ts"
      provides: "Game CRUD + auto-recalculate season record"
      exports: ["createGame", "getGamesBySeason", "updateGame", "deleteGame", "recalculateSeasonRecord"]
    - path: "apps/desktop/src/store/season-store.ts"
      provides: "Zustand store for season state"
      exports: ["useSeasonStore"]
    - path: "apps/desktop/src/store/game-store.ts"
      provides: "Zustand store for game state"
      exports: ["useGameStore"]
  key_links:
    - from: "apps/desktop/src/lib/game-service.ts"
      to: "apps/desktop/src/lib/season-service.ts"
      via: "recalculateSeasonRecord updates Season.wins/losses/confWins/confLosses after game mutations"
      pattern: "updateSeason.*wins.*losses"
    - from: "apps/desktop/src/store/game-store.ts"
      to: "apps/desktop/src/lib/game-service.ts"
      via: "store actions call service functions then reload"
      pattern: "createGame|updateGame|deleteGame"
    - from: "apps/desktop/src/store/season-store.ts"
      to: "apps/desktop/src/lib/season-service.ts"
      via: "store actions call service functions then reload"
      pattern: "createSeason|getSeasonsByDynasty"
---

<objective>
Create the season and game data layer — service functions for CRUD operations with auto-calculated
win/loss records, and Zustand stores following the established dynasty-store pattern.

Purpose: All dashboard widgets, game entry forms, and season displays depend on this data layer.
Without it, no UI can read or write season/game data.

Output: Four new files (two services, two stores) and updated store barrel export.
</objective>

<execution_context>
@/Users/chanmoore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chanmoore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow
@apps/desktop/src/lib/dynasty-service.ts
@apps/desktop/src/store/dynasty-store.ts
@apps/desktop/src/store/index.ts
@apps/desktop/src/lib/uuid.ts

# Types already defined — use exactly as they are
@packages/core-types/src/season.ts
@packages/core-types/src/game.ts
@packages/core-types/src/dynasty.ts
@packages/core-types/src/sport-config.ts

# DB schema — seasons and games tables already exist
@packages/db/src/schema.ts
@packages/db/src/dynasty-db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create season-service.ts and game-service.ts</name>
  <files>
    apps/desktop/src/lib/season-service.ts
    apps/desktop/src/lib/game-service.ts
  </files>
  <action>
    Create `apps/desktop/src/lib/season-service.ts`:

    Follow the dynasty-service.ts pattern exactly (import db from @dynasty-os/db, import types
    from @dynasty-os/core-types, use generateId from ./uuid).

    Export these functions:
    - `createSeason(input: { dynastyId: string; year: number }): Promise<Season>` —
      Create season with dynastyId, year, wins: 0, losses: 0, confWins: 0, confLosses: 0,
      createdAt/updatedAt timestamps. Use generateId() for id.
    - `getSeasonsByDynasty(dynastyId: string): Promise<Season[]>` —
      Query `db.seasons.where('dynastyId').equals(dynastyId)` and sort by year descending.
    - `getSeason(id: string): Promise<Season | undefined>` — Direct get by id.
    - `getCurrentSeason(dynastyId: string): Promise<Season | undefined>` —
      Get all seasons for dynasty, return the one with the highest year. Return undefined if none.
    - `updateSeason(id: string, updates: Partial<Omit<Season, 'id' | 'dynastyId' | 'createdAt'>>): Promise<void>` —
      Call `db.seasons.update(id, { ...updates, updatedAt: Date.now() })`.

    Create `apps/desktop/src/lib/game-service.ts`:

    Export these functions:
    - `createGame(input: Omit<Game, 'id' | 'createdAt' | 'updatedAt'>): Promise<Game>` —
      Add timestamps and generateId(), put into db.games, then call recalculateSeasonRecord(input.seasonId).
    - `getGamesBySeason(seasonId: string): Promise<Game[]>` —
      Query `db.games.where('seasonId').equals(seasonId)` and sort by week ascending.
    - `getRecentGames(dynastyId: string, limit: number): Promise<Game[]>` —
      Query `db.games.where('dynastyId').equals(dynastyId)`, sort by createdAt descending, take limit.
    - `updateGame(id: string, updates: Partial<Omit<Game, 'id' | 'seasonId' | 'dynastyId' | 'createdAt'>>): Promise<void>` —
      Update the game with updatedAt timestamp. Then get the game to find its seasonId,
      call recalculateSeasonRecord(seasonId).
    - `deleteGame(id: string): Promise<void>` —
      Get the game first (to capture seasonId), delete it, then call recalculateSeasonRecord(seasonId).
    - `recalculateSeasonRecord(seasonId: string): Promise<void>` —
      Get all games for the season. Count: wins = games with result 'W', losses = result 'L'.
      For conference record: count only games where gameType is 'conference'.
      Call updateSeason(seasonId, { wins, losses, confWins, confLosses }).

    IMPORTANT type alignment: Use exact types from @dynasty-os/core-types:
    - GameResult is 'W' | 'L' | 'T' (not 'win'/'loss')
    - GameType includes 'conference' (use this for conference games, not 'regular')
    - Season uses wins/losses/confWins/confLosses (not nested objects)
    - Game uses teamScore/opponentScore (not score.us/score.them)
    - Game has overtime: boolean field
  </action>
  <verify>
    Run `cd /Users/chanmoore/dev/dynasty-os && pnpm exec tsc --noEmit -p apps/desktop/tsconfig.json`
    and confirm no type errors in the new service files.
  </verify>
  <done>
    season-service.ts exports 5 functions for Season CRUD.
    game-service.ts exports 6 functions including recalculateSeasonRecord that auto-updates
    Season.wins/losses/confWins/confLosses after every game mutation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create season-store.ts and game-store.ts Zustand stores</name>
  <files>
    apps/desktop/src/store/season-store.ts
    apps/desktop/src/store/game-store.ts
    apps/desktop/src/store/index.ts
  </files>
  <action>
    Create `apps/desktop/src/store/season-store.ts`:

    Follow the dynasty-store.ts pattern exactly (create<T> from zustand, state + actions interface,
    loading/error pattern).

    State:
    - seasons: Season[] (all seasons for active dynasty)
    - activeSeason: Season | null (the current/latest season)
    - loading: boolean
    - error: string | null

    Actions:
    - `loadSeasons(dynastyId: string): Promise<void>` — Fetch all seasons, set activeSeason to
      the one with highest year (or null if none).
    - `createSeason(dynastyId: string, year: number): Promise<Season>` —
      Call createSeason service, reload seasons, set the new season as active.
    - `updateSeason(id: string, updates): Promise<void>` — Call updateSeason service, reload.
    - `setActiveSeason(season: Season | null): void` — Direct set.
    - `clearError(): void`

    Create `apps/desktop/src/store/game-store.ts`:

    State:
    - games: Game[] (games for active season, sorted by week)
    - loading: boolean
    - error: string | null

    Actions:
    - `loadGames(seasonId: string): Promise<void>` — Fetch games for season, sorted by week.
    - `logGame(input: Omit<Game, 'id' | 'createdAt' | 'updatedAt'>): Promise<Game>` —
      Call createGame service, reload games. IMPORTANT: After game is created,
      the season record has been auto-recalculated by the service. The caller (UI) should
      also trigger season store reload to reflect updated W/L.
    - `updateGame(id: string, updates): Promise<void>` — Call updateGame service, reload.
    - `deleteGame(id: string): Promise<void>` — Call deleteGame service, reload.
    - `clearError(): void`

    Update `apps/desktop/src/store/index.ts`:
    Add exports for useSeasonStore and useGameStore alongside the existing useDynastyStore export.
  </action>
  <verify>
    Run `cd /Users/chanmoore/dev/dynasty-os && pnpm exec tsc --noEmit -p apps/desktop/tsconfig.json`
    and confirm no type errors. Verify store/index.ts exports all three stores.
  </verify>
  <done>
    useSeasonStore and useGameStore are exported from store/index.ts.
    Both stores follow the dynasty-store pattern: loading/error state, reload after mutations.
    Game store's logGame calls createGame which auto-recalculates season record.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit -p apps/desktop/tsconfig.json` — zero errors
2. All service functions use correct types from @dynasty-os/core-types (GameResult 'W'|'L'|'T', not 'win'|'loss')
3. recalculateSeasonRecord correctly counts conference games using gameType === 'conference'
4. Both stores export from store/index.ts alongside useDynastyStore
5. `pnpm run build` from repo root succeeds
</verification>

<success_criteria>
- season-service.ts and game-service.ts compile with correct types
- recalculateSeasonRecord updates Season wins/losses/confWins/confLosses from game data
- useSeasonStore and useGameStore follow dynasty-store pattern and are exported from index
- All files use existing patterns: generateId(), db from @dynasty-os/db, types from @dynasty-os/core-types
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-loop/02-01-SUMMARY.md`
</output>
